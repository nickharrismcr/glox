
import random as rn
import colour
from math import * 

const SPEED=8 
const TRAIL=100
const LINES=100

func random_vec2D (minX, maxX, minY, maxY) {
    return vec2(rn.integer(minX, maxX), rn.integer(minY, maxY))
}

// A simple buffer that rotates its contents when full
// and appends new values to the end.
class Buffer{
    init(size) {
        this.size = size
        this.data = []
    }
    append(value) {
        if (len(this.data) >= this.size) {
            this.data[0]= value
            this.data = this.shift_list(this.data)
        } else {
            this.data.append(value)
        }
    }
    shift_list(lst) {
        var new_lst = []
        for (var i = 1; i < len(lst); i = i + 1) {
            new_lst.append(lst[i])
        }
        return new_lst
    }
    // Returns the length of the list
    len(lst) {
        return lst.length
    }
    toString() {
        return "Buffer(" + str(this.size) + ", " + str(this.data) + ")"
    }
}

// A line that moves around the screen and leaves a trail
class Line {
    init(pos1,pos2,col, width, height) {
        this.pos1 = pos1
        this.pos2 = pos2 
        this.col=col
      
        this.d1= random_vec2D(-SPEED, SPEED, -SPEED, SPEED)
        this.d2= random_vec2D(-SPEED, SPEED, -SPEED, SPEED)
        this.width = width
        this.height = height
        this.hist = Buffer(TRAIL)
        this.counter= 0
    }
    move(){
        this.hist.append(this.copy()); 
        this.pos1 = add2d(this.pos1, this.d1)
        this.pos2 = add2d(this.pos2, this.d2)
        if (this.pos1.x < 0 or this.pos1.x > this.width) {
            this.d1.x = -this.d1.x
        }
        if (this.pos1.y < 0 or this.pos1.y > this.height) { 
            this.d1.y = -this.d1.y
        }
        if (this.pos2.x < 0 or this.pos2.x > this.width) {
            this.d2.x = -this.d2.x;
        }
        if (this.pos2.y < 0 or this.pos2.y > this.height) {
            this.d2.y = -this.d2.y
        }
        
    }
    draw(g) {
        g.line(this.pos1, this.pos2, this.col)
        c=1.0
        foreach (var l in this.hist.data[1:]) {
            c = c + 1.0
            a = 255.0 * (c / (1.1*len(this.hist.data))) ; 
           
            g.line(l.pos1, l.pos2, vec4(l.col.r, l.col.g, l.col.b, a)) 
        }   
    }

    new() {
        return Line(this.pos1, this.pos2, this.col, this.width, this.height)
    }
    toString() {
        return "Line(" + str(this.pos1) + ", " + str(this.pos2) + ", " + str(this.col) + ")"
    }
    copy() {
        return Line(vec2(this.pos1.x, this.pos1.y), vec2(this.pos2.x, this.pos2.y), vec4(this.col.r, this.col.g, this.col.b, this.col.a)  , this.width, this.height)
    }
}

// A collection of lines 
class Lines {
    init(width, height ){
        this.width = width
        this.height = height
        this.lines = []
    }
    add_line(pos1, pos2, col) {
        var line = Line(pos1,pos2,col, this.width, this.height)
        this.lines.append(line)
    }
    update() {
        foreach ( var l in this.lines ) {
            l.move()
        }
    }
    draw(g) {
        foreach ( var l in this.lines ) {
            l.draw(g)
        }
    }
}
 

const width=1500
const height=900
var win = window(width,height)
win.init()

lines=Lines(width, height);

for (var i = 0; i < LINES; i = i + 1) {
    var pos = random_vec2D(0, width, 0, height)
    var pos2 = random_vec2D(0, width, 0, height)
    var col = colour.random_rgb(); 
    col.a = rn.integer(0, 255)
    lines.add_line(pos,pos2,col) 
}

while (!win.should_close()) {

     win.clear(vec4(60,10,10, 255))

    lines.update()
    win.begin_blend_mode(win.BLEND_MULTIPLY)
    lines.draw(win)
    win.end_blend_mode()
    
    win.end()
}
win.close()