// 3D Demo with Moving Objects, Explosions, and Shadows
// This example demonstrates 3D rendering, moving objects, basic physics, and pseudo-shadows

import colour  as col
import random
import math
 


win = window(1,1)
win.init()
win.toggle_fullscreen()
 

// Create a camera
// position, target, up vector
cam = camera(vec3(20, 10, 10), vec3(0, 0, 0), vec3(0, 1, 0))

angle = 0.0
frame_count = 0
floor_flash_timer = 0  // Timer for floor flash effect

// Grid bounds
const GRID_SIZE = 20.0
const BOUNCE_DAMPING = 0.9
const SHAPES=150
const FORCE=0.9   // explosion force strength
const DISTANCE = 40.0  // Distance from camera to center of grid

// Moving object class
class MovingObject {
    init(pos, vel, size, color, shape_type) {
        this.pos = pos
        this.vel = vel
        this.size = size
        this.color = color
        this.shape_type = shape_type  // "cube", "sphere", "cylinder"
        this.radius = this.get_collision_radius()
        this.explosion_timer = random.float(500, 13200)  // Random time until explosion (frames)
        this.is_exploded = false
    }
    
    get_collision_radius() {
        return this.size.x
    }
    
    distance_to(other) {
        dx = this.pos.x - other.pos.x
        dy = this.pos.y - other.pos.y
        dz = this.pos.z - other.pos.z
        return sqrt(dx*dx + dy*dy + dz*dz)
    }
    
    // Fast collision check - avoids sqrt when possible
    distance_squared_to(other) {
        dx = this.pos.x - other.pos.x
        dy = this.pos.y - other.pos.y
        dz = this.pos.z - other.pos.z
        return dx*dx + dy*dy + dz*dz
    }
    
    check_collision(other) {
        radiusSum = this.radius + other.radius
        return this.distance_squared_to(other) < (radiusSum * radiusSum)
    }
    
    resolve_collision(other) {
        dx = this.pos.x - other.pos.x
        dy = this.pos.y - other.pos.y
        dz = this.pos.z - other.pos.z
        dist = sqrt(dx*dx + dy*dy + dz*dz)
        
        if (dist == 0) {
            // Objects are at same position, push them apart randomly
            dx = random.float(-1, 1)
            dy = random.float(-1, 1)
            dz = random.float(-1, 1)
            dist = sqrt(dx*dx + dy*dy + dz*dz)
        }
        
        // Normalize collision vector
        nx = dx / dist
        ny = dy / dist
        nz = dz / dist
        
        // Separate overlapping objects
        overlap = (this.radius + other.radius) - dist
        separation = overlap / 2
        
        this.pos.x = this.pos.x + nx * separation
        this.pos.y = this.pos.y + ny * separation
        this.pos.z = this.pos.z + nz * separation
        
        other.pos.x = other.pos.x - nx * separation
        other.pos.y = other.pos.y - ny * separation
        other.pos.z = other.pos.z - nz * separation
        
        // Calculate relative velocity
        rel_vel_x = this.vel.x - other.vel.x
        rel_vel_y = this.vel.y - other.vel.y
        rel_vel_z = this.vel.z - other.vel.z
        
        // Calculate relative velocity in collision normal direction
        vel_along_normal = rel_vel_x * nx + rel_vel_y * ny + rel_vel_z * nz
        
        // Don't resolve if velocities are separating
        if (vel_along_normal > 0) {
            return
        }
        
        // Calculate restitution (bounciness)
        restitution = 0.7
        impulse = -(1 + restitution) * vel_along_normal
        
        // Apply impulse to velocities (assuming equal mass)
        impulse = impulse / 2
        
        this.vel.x = this.vel.x + impulse * nx
        this.vel.y = this.vel.y + impulse * ny
        this.vel.z = this.vel.z + impulse * nz
        
        other.vel.x = other.vel.x - impulse * nx
        other.vel.y = other.vel.y - impulse * ny
        other.vel.z = other.vel.z - impulse * nz
    }
    
    update() {
        // Skip update if exploded
        if (this.is_exploded) {
            return
        }
        
        // Countdown to explosion
        this.explosion_timer = this.explosion_timer - 1
        
        // Update position
        this.pos.x = this.pos.x + this.vel.x
        this.pos.y = this.pos.y + this.vel.y
        this.pos.z = this.pos.z + this.vel.z
        
        // Bounce off boundaries
        if (this.pos.x > GRID_SIZE or this.pos.x < -GRID_SIZE) {
            this.vel.x = -this.vel.x * BOUNCE_DAMPING
            if (this.pos.x > GRID_SIZE) this.pos.x = GRID_SIZE
            if (this.pos.x < -GRID_SIZE) this.pos.x = -GRID_SIZE
        }
        
        if (this.pos.z > GRID_SIZE or this.pos.z < -GRID_SIZE) {
            this.vel.z = -this.vel.z * BOUNCE_DAMPING
            if (this.pos.z > GRID_SIZE) this.pos.z = GRID_SIZE
            if (this.pos.z < -GRID_SIZE) this.pos.z = -GRID_SIZE
        }
        
        // Keep objects above ground with bouncing
        ground_level = 0.0  // Plane is at Y=0
        if (this.pos.y - this.radius < ground_level) {
            this.pos.y = ground_level + this.radius  // Bottom of sphere touches ground
            this.vel.y = -this.vel.y * BOUNCE_DAMPING
        }
        
        // Add gravity
        this.vel.y = this.vel.y - 0.01
 
    }
    
    // Check if this ball should explode
    should_explode() {
        return this.explosion_timer <= 0 and !this.is_exploded
    }
    
    // Explode this ball
    explode() {
        this.is_exploded = true
    }
    
    // Apply explosion force to this ball from an explosion at explosion_pos
    apply_explosion_force(explosion_pos, explosion_force) {
        if (this.is_exploded) {
            return
        }
        
        // Calculate distance and direction from explosion
        dx = this.pos.x - explosion_pos.x
        dy = this.pos.y - explosion_pos.y
        dz = this.pos.z - explosion_pos.z
        dist = sqrt(dx*dx + dy*dy + dz*dz)
        
        // Only affect balls within explosion radius
        explosion_radius = 8.0
        if (dist > explosion_radius or dist < 0.1) {
            return
        }
        
        // Normalize direction
        nx = dx / dist
        ny = dy / dist
        nz = dz / dist
        
        // Calculate force based on distance (closer = more force)
        force_strength = explosion_force * (1.0 - (dist / explosion_radius))
        
        // Apply the force to velocity
        this.vel.x = this.vel.x + nx * force_strength
        this.vel.y = this.vel.y + ny * force_strength  // No upward boost
        this.vel.z = this.vel.z + nz * force_strength
    }
    
    draw(win) {
        // Don't draw if exploded
        if (this.is_exploded) {
            return
        }

        // Flash white when about to explode (last 5 frames)
        if (this.explosion_timer > 0 and this.explosion_timer < 5) {
            flash_intensity = (5 - this.explosion_timer) / 5.0
            // Triple the size when flashing white
            expanded_size = this.size.x * 3.0
            win.sphere(this.pos, expanded_size, col.WHITE)
        } else {
            win.sphere(this.pos, this.size.x, this.color)
        }
    }
    
    draw_shadow(win) {
        // Don't draw shadow if exploded
        if (this.is_exploded) {
            return
        }
        
        // Calculate shadow position (directly below sphere on ground)
        shadow_pos = vec3(this.pos.x, 0.01, this.pos.z)  // Slightly above ground to avoid z-fighting
        
        // Shadow size based on sphere height and radius
        height_factor = math.max(0.2, 1.0 - (this.pos.y / 7.0))  // Closer to ground = bigger shadow
        shadow_radius_x = this.radius * height_factor  
        shadow_radius_z = this.radius * height_factor  
        
        // Shadow alpha based on height (higher = more transparent)
 
        shadow_color = vec4(100, 100, 100, 255)  // Gray shadow with variable transparency

        win.ellipse(shadow_pos, shadow_radius_x, shadow_radius_z, shadow_color)
    }
}

// Create moving objects
objects = []


// Add some spheres
for (i = 0; i < SHAPES; i = i + 1) {
    pos = vec3(random.float(-5, 5), random.float(10, 18), random.float(-5, 5))
    vel = vec3(random.float(-0.15, 0.15), random.float(-0.05, 0.05), random.float(-0.15, 0.15))
    s = random.float(0.3,0.7)
    size = vec3(s, s, s)
    objects.append(MovingObject(pos, vel, size, col.random_rgb(), "sphere"))
}

 

while (!win.should_close()) {
    // Update camera
    angle = angle + 0.005
    x = cos(angle) * DISTANCE
    z = sin(angle) * DISTANCE
    cam.set_position(vec3(x, 10, z))
    
    frame_count = frame_count + 1
    
    // Update all moving objects
    foreach (obj in objects) {
        obj.update()
    }
    
    // Check for explosions
    explosions = []
    for (i = 0; i < objects.length(); i = i + 1) {
        obj = objects[i]
        if (obj.should_explode()) {
            explosions.append(vec3(obj.pos.x, obj.pos.y, obj.pos.z))  // Store explosion position
            obj.explode()
        }
    }
    
    // If there were explosions, trigger floor flash
    if (explosions.length() > 0) {
        floor_flash_timer = 10  // Flash for 10 frames
    }
    
    // Countdown floor flash timer
    if (floor_flash_timer > 0) {
        floor_flash_timer = floor_flash_timer - 1
    }
    
    // Apply explosion forces to all objects
    foreach (explosion_pos in explosions) {
        foreach (obj in objects) {
            obj.apply_explosion_force(explosion_pos, FORCE)  // Explosion force strength
        }
    }
    
    // Remove exploded objects
    new_objects = []
    foreach (obj in objects) {
        if (!obj.is_exploded) {
            new_objects.append(obj)
        }
    }
    objects = new_objects
    
    // Only do collision detection every other frame for 300+ objects
    if (frame_count % 3 == 0) {
        // Spatial partitioning collision detection
        collision_checks = 0
        grid_size = 4.0  // Larger grid cells for fewer checks
        
        for (i = 0; i < objects.length(); i = i + 1) {
            for (j = i + 1; j < objects.length(); j = j + 1) {
                obj1 = objects[i]
                obj2 = objects[j]
                
                // Quick distance pre-check - only check very close objects
                dx = obj1.pos.x - obj2.pos.x
                dy = obj1.pos.y - obj2.pos.y
                dz = obj1.pos.z - obj2.pos.z
                
                // Skip if too far apart (much more aggressive culling)
                if (dx*dx + dz*dz > 4) {  // Only check within 2 units horizontally
                    continue
                }
                if (dy*dy > 9) {  // Only check within 3 units vertically
                    continue
                }
                
                collision_checks = collision_checks + 1
                if (obj1.check_collision(obj2)) {
                    obj1.resolve_collision(obj2)
                }
            }
        }
    }
    
    win.begin()
    win.begin_blend_mode(win.BLEND_ALPHA)
    win.clear(vec4(100,100,150,255))

    // Begin 3D mode
    win.begin_3d(cam)
    
    // Draw a flat square ground plane - flash white during explosions
    if (floor_flash_timer > 0) {
        // Flash intensity decreases over time
        flash_intensity = floor_flash_timer / 10.0
        flash_white = int(150 + (255 - 150) * flash_intensity)  // Interpolate to white
        floor_color = vec4(flash_white, flash_white, flash_white, 255)
        win.plane(vec3(0, 0, 0), vec2(GRID_SIZE*2, GRID_SIZE*2), floor_color)
    } else {
        win.plane(vec3(0, 0, 0), vec2(GRID_SIZE*2, GRID_SIZE*2), vec4(150, 150, 150, 255))
    }
    
    // Draw shadows first (so they appear under objects)
    foreach (obj in objects) {
        obj.draw_shadow(win)
    }
    
    // Draw boundary walls as wireframes
    win.cube_wires(vec3(0, 5, 0), vec3(GRID_SIZE*2, 10, GRID_SIZE*2), vec4(100, 100, 100, 100))
    
    // Draw all moving objects
    foreach (obj in objects) {
        obj.draw(win)
    }

    // End 3D mode
    win.end_3d()
    
    win.end()
}

win.close()
