// Massive Batched Cubes Demo - Performance Stress Test
// Demonstrates batch drawing with thousands of cubes that would be impossible with individual lox draw calls.
// Batch maintains a list of cubes, when lox does a batch draw call, vm does a raylib draw call for each cube in the batch.
// This is not mesh instancing, that is a future feature and would be much more efficient.

import math
import random
import colour_utils
import sys
import itertools

// Configuration for massive cube grid (now a 3D cube of cubes)
const GRID_SIZE = 15       // 10x10x10 = 1,000 cubes!
const CUBE_SPACING = 30     // Space between cubes
const CUBE_SIZE = 2       // Individual cube size
const WAVE_HEIGHT = 2.0      // Height of wave animation
const WAVE_SPEED = 2.0       // Speed of wave propagation
const COLOR_SPEED = 5     // Speed of color animation

// Window setup  
const WIDTH = 1600
const HEIGHT = 1000

win = window(WIDTH, HEIGHT)
win.init()
win.toggle_fullscreen()   

// Create camera positioned to see the massive cube
var grid_center = (GRID_SIZE - 1) * CUBE_SPACING / 2
var cam_pos = vec3(grid_center + 40, grid_center + 40, grid_center + 40)
var cam_target = vec3(grid_center, grid_center, grid_center)
var cam_up = vec3(0, 1, 0)
cam = camera(cam_pos, cam_target, cam_up)

// Create a batch for cubes
var cube_batch = batch(win.BATCH_CUBE)

// Massive cube data structure - optimized for thousands of cubes
class MassiveCube {
    init(x, y, z, gridX, gridY, gridZ) {
        this.basePos = vec3(x, y, z)
        this.gridX = gridX
        this.gridY = gridY
        this.gridZ = gridZ
        this.timeOffset = random.float(0, 6.28)  // Random phase offset for waves
        this.colorOffset = random.float(0, 1.0)  // Random color offset
        // Initial position and color
        var hue = int((gridX + gridY + gridZ) * 10) % 360
        var initialColor = colour_utils.hsv_to_rgb(hue, 0.8, 1.0)
        // Add to batch and store index
        this.baseSize = CUBE_SIZE + random.float(-0.2, 0.2) // Store base size with small random variation
        var sizeVec = vec3(this.baseSize, this.baseSize, this.baseSize)
        this.batch_index = cube_batch.add(this.basePos, sizeVec, initialColor)
    }
    
    update(time,bouncer) {
        // No height animation, just use base position
        var newPos = this.basePos
        // Animate size with a triangle ramp using Bouncer
        var sizePulse = bouncer.x  // Value bounces between 0 and 1
        var newSize = this.baseSize * sizePulse
        var sizeVec = vec3(newSize, newSize, newSize)
        // Update position and size in batch
        cube_batch.set_position(this.batch_index, newPos)
        cube_batch.set_size(this.batch_index, sizeVec)
        
        // Animate colors in 3D from the center of the cube, with longer wavelength (more uniform)
        var colorDist = math.sqrt(
            math.pow(this.basePos.x - grid_center, 2) +
            math.pow(this.basePos.y - grid_center, 2) +
            math.pow(this.basePos.z - grid_center, 2)
        )
        var colorTime = time * (COLOR_SPEED * 0.25) + colorDist * 0.04 + this.colorOffset  // slower time, less spatial variation
        var hue = int(colorTime * 18) % 360  // much longer color wavelength
        var saturation = 0.7 + math.sin(colorTime * 0.5) * 0.2  // less pulsing
        var brightness = 0.8 + math.sin(colorTime * 0.4) * 0.15  // less pulsing
        var newColor = colour_utils.hsv_to_rgb(hue, saturation, brightness)
        cube_batch.set_color(this.batch_index, newColor)
    }
}

// Create MASSIVE grid of cubes - this would be impossible with individual draw calls!
var cubes = []
var cubeCount = 0

print("Creating massive cube grid...")
print("Grid size:", GRID_SIZE, "x", GRID_SIZE, "=", GRID_SIZE * GRID_SIZE, "cubes")

var startTime = sys.clock()

// Create the massive 3D grid (cube of cubes)
for (var x = 0; x < GRID_SIZE; x = x + 1) {
    for (var y = 0; y < GRID_SIZE; y = y + 1) {
        for (var z = 0; z < GRID_SIZE; z = z + 1) {
            var worldX = x * CUBE_SPACING
            var worldY = y * CUBE_SPACING
            var worldZ = z * CUBE_SPACING
            cubes.append(MassiveCube(worldX, worldY, worldZ, x, y, z))
            cubeCount = cubeCount + 1
            // Show progress every 2000 cubes
            if (cubeCount % 2000 == 0) {
                print("Created", cubeCount, "cubes...")
            }
        }
    }
}

var endTime = sys.clock()
var creationTime = endTime - startTime
 
// Simple time tracking
var last_time = 0

// Performance tracking
var frameCount = 0
var fpsUpdateTime = 0
var currentFPS = 0

bouncer = itertools.Bouncer(0.8, 1.2, 0.0005)
 
while (!win.should_close()) {
    var current_time = sys.clock()
    var delta_time = current_time - last_time
    last_time = current_time
    
    // Cap delta time to avoid big jumps
    if (delta_time > 0.1) {
        delta_time = 0.016
    }
    
    // Update FPS counter
    frameCount = frameCount + 1
    fpsUpdateTime = fpsUpdateTime + delta_time
    if (fpsUpdateTime >= 1.0) {
        currentFPS = frameCount
        frameCount = 0
        fpsUpdateTime = 0
    }
    bouncer.update()
    // Update all cubes with current time (much more efficient than deltaTime for waves)
    var updateStart = sys.clock()
    for (var i = 0; i < len(cubes); i = i + 1) {
        cubes[i].update(current_time, bouncer)  // Pass bouncer for size animation
    }
    var updateEnd = sys.clock()
    var updateTime = updateEnd - updateStart
    
    // Render everything
    var renderStart = sys.clock()
    win.begin()
    win.begin_blend_mode(win.BLEND_ALPHA)  // Enable alpha blending for smooth colors
    win.clear(vec4(10, 15, 25, 255))  // Dark background to see wave colors
    
    // Rotate camera around the center of the cube grid, and modulate x/z distance from center
    var base_radius = GRID_SIZE * CUBE_SPACING * 0.7
    var cam_angle = current_time * 0.18
    var cam_radius = base_radius + math.sin(current_time * 0.07) * (GRID_SIZE * CUBE_SPACING * 0.25)
    cam_pos.x = grid_center + cam_radius * math.cos(cam_angle)
    cam_pos.y = grid_center + base_radius * 0.4 + math.sin(current_time * 0.13) * GRID_SIZE * 2.0  // slight vertical bobs+ math.sin(current_time * 0.035) * (GRID_SIZE * CUBE_SPACING * 0.18)  // slow y oscillation
    cam_pos.z = grid_center + cam_radius * math.sin(cam_angle)
    cam.set_position(cam_pos)
    // Oscillate camera look direction (target) up and down slowly
    var look_osc = math.sin(current_time * 0.5) * (GRID_SIZE * 5)
    cam_target.y = grid_center + look_osc
    cam.set_target(cam_target)
    win.begin_3d(cam)
    
    // Draw all cubes in ONE SINGLE BATCHED CALL!
    cube_batch.draw()
    
    win.end_3d()
    
    // Performance info display
 
    win.text(format("Total cubes: %d", cubeCount), 10, 40, 18, vec4(255, 255, 255, 255))
    win.text(format("Batch entries: %d", cube_batch.count()), 10, 65, 18, vec4(255, 255, 255, 255))
    win.text(format("FPS: %d", currentFPS), 10, 90, 18, vec4(100, 255, 100, 255))
    win.text(format("Update time: %d ms", int(updateTime * 1000)), 10, 115, 16, vec4(200, 200, 255, 255))
    win.text("ðŸŽ® ESC to exit", 10, 215, 16, vec4(200, 200, 200, 255))
    win.end_blend_mode()
    win.end()
    var renderEnd = sys.clock()
    var renderTime = renderEnd - renderStart
    
    // Exit on ESC
    if (win.key_pressed(win.KEY_ESCAPE)) {
        break
    }
}

win.close()
 
