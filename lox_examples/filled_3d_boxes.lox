import colour, random , itertools 
 

class Cube {
    init(center, size) {
        this.center = center
        this.size = size
        this.angleX = 0.0
        this.angleY = 0.0
        this.angleZ = 0.0
        this.points3d = []
        this.points2d = []
        this.update_points()
        this.dx = random.float(0.01,0.03)
        this.dy = random.float(0.01,0.03)
        this.dz = random.float(0.01,0.03)
        this.vel = vec2(random.float(-3,3), random.float(-3,3))
    }
    update_points() {
        s = this.size / 2
        pts = [vec3(-s, -s, -s), vec3(s, -s, -s), vec3(s, s, -s), vec3(-s, s, -s), vec3(-s, -s, s), vec3(s, -s, s), vec3(s, s, s), vec3(-s, s, s)]
        ax = this.angleX
        ay = this.angleY
        az = this.angleZ
        this.points2d = []
        foreach (p in pts) {
            y1 = p.y * cos(ax) - p.z * sin(ax)
            z1 = p.y * sin(ax) + p.z * cos(ax)
            x2 = p.x * cos(ay) + z1 * sin(ay)
            z2 = -p.x * sin(ay) + z1 * cos(ay)
            x3 = x2 * cos(az) - y1 * sin(az)
            y3 = x2 * sin(az) + y1 * cos(az)
            d = 500.0
            f = d / (d + z2)
            px = this.center.x + x3 * f
            py = this.center.y + y3 * f
            this.points2d.append(vec2(px, py))
        }
        this.face_colours = [vec4(255,40,40,255), vec4(200,30,30,255), vec4(160,20,20,255), vec4(120,10,10,255), vec4(255,80,80,255), vec4(100,0,0,255)]
    }
    update(win_width, win_height) {
        this.angleX = this.angleX + this.dx
        this.angleY = this.angleY + this.dy
        this.angleZ = this.angleZ + this.dz
        this.center.x = this.center.x + this.vel.x
        this.center.y = this.center.y + this.vel.y
        s = this.size / 2
        if (this.center.x - s < 0) {
            this.center.x = s
            this.vel.x = -this.vel.x
        }
        if (this.center.x + s > win_width) {
            this.center.x = win_width - s
            this.vel.x = -this.vel.x
        }
        if (this.center.y - s < 0) {
            this.center.y = s
            this.vel.y = -this.vel.y
        }
        if (this.center.y + s > win_height) {
            this.center.y = win_height - s
            this.vel.y = -this.vel.y
        }
        this.update_points()
    }
    draw(win ) {

        func sorter(a, b) {
            if (b[0] > a[0]) return 1
            if (b[0] < a[0]) return -1
            return 0
        }
        col = vec4(255, 255, 255, 0)
        faces = [[0,1,2,3], [4,5,6,7], [0,1,5,4], [2,3,7,6], [1,2,6,5], [0,3,7,4]  ]
        // Compute average z for each face for painter's algorithm
        zlist = []
        pts3d = [vec3(-this.size/2, -this.size/2, -this.size/2), vec3(this.size/2, -this.size/2, -this.size/2), vec3(this.size/2, this.size/2, -this.size/2), vec3(-this.size/2, this.size/2, -this.size/2), vec3(-this.size/2, -this.size/2, this.size/2), vec3(this.size/2, -this.size/2, this.size/2), vec3(this.size/2, this.size/2, this.size/2), vec3(-this.size/2, this.size/2, this.size/2)]
        ax = this.angleX
        ay = this.angleY
        az = this.angleZ
        z3d = []
        foreach (p in pts3d) {
            y1 = p.y * cos(ax) - p.z * sin(ax)
            z1 = p.y * sin(ax) + p.z * cos(ax)
            x2 = p.x * cos(ay) + z1 * sin(ay)
            z2 = -p.x * sin(ay) + z1 * cos(ay)
            x3 = x2 * cos(az) - y1 * sin(az)
            y3 = x2 * sin(az) + y1 * cos(az)
            z3d.append(z2)
        }
        for (i = 0; i < len(faces); i = i + 1) {
            f = faces[i]
            avgz = (z3d[f[0]] + z3d[f[1]] + z3d[f[2]] + z3d[f[3]]) / 4.0
            zlist.append([avgz, i])
        }
        // Sort faces by avgz (back to front)
        zlist = itertools.sort(zlist, sorter) 
 
        // Draw filled faces
        
        for (k = 0; k < len(zlist); k = k + 1) {
            f = faces[zlist[k][1]]
            p0 = this.points2d[f[0]]; p1 = this.points2d[f[1]]; p2 = this.points2d[f[2]]; p3 = this.points2d[f[3]]
            face_col = this.face_colours[zlist[k][1] % len(this.face_colours)]
            area1 = (p1.x - p0.x) * (p2.y - p0.y) - (p1.y - p0.y) * (p2.x - p0.x)
            if (area1 < 0) {
                win.triangle(p0, p1, p2, face_col)
            } else {
                win.triangle(p0, p2, p1, face_col)
            }
            area2 = (p2.x - p0.x) * (p3.y - p0.y) - (p2.y - p0.y) * (p3.x - p0.x)
            if (area2 < 0) {
                win.triangle(p0, p2, p3, face_col)
            } else {
                win.triangle(p0, p3, p2, face_col)
            }
        }
        // Draw wireframe on top
        e = [[0,1],[1,2],[2,3],[3,0],[4,5],[5,6],[6,7],[7,4],[0,4],[1,5],[2,6],[3,7]]
        for (i = 0; i < len(e); i = i + 1) {
            a = this.points2d[e[i][0]]; b = this.points2d[e[i][1]]
            win.line(a, b, col)
        }
    }
}

 
win = window(0,0)
win.init()
win.toggle_fullscreen()
width = win.get_screen_width()
height = win.get_screen_height()    

cubes =[] 
 
for (i=0; i<40; i=i+1 ){
    pos= vec2(random.float(100, width-100), random.float(100, height-100))
    size = random.float(40,170)
    cubes.append(Cube(pos, size))
}
 
while (!win.should_close()) {
    win.begin()
    win.begin_blend_mode(win.BLEND_ALPHA)
    win.clear(vec4(0,0,0,255))
    foreach (cube in cubes) {
        cube.update(width, height)
        cube.draw(win )
    }
    win.end()
}
win.close()
