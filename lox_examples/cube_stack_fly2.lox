// Cube Stack Fly 2.0 - Redesigned with batched rendering and cleaner architecture
// Based on the design in cube_stack_fly.design.md

import math
import random
import colour_utils

const FULLSCREEN = false 

// Configuration constants
const CITY_SIZE = 50         // 50x50 grid (odd positions for stacks, even for streets)
const STACK_SPACING = 6.0    // Reduced from 16.0 for denser city
const MIN_STACK_HEIGHT = 3
const MAX_STACK_HEIGHT = 20
const BASE_CUBE_SIZE = 2.0
const CAMERA_HEIGHT = 8.0
const MAX_CAMERA_SPEED = 1  // Faster speed for simplified movement
const ACCELERATION_FRAMES = 15
const DECELERATION_FRAMES = 15
const ROTATION_FRAMES = 15

// Direction constants
const NORTH = "0"
const EAST = "1"
const SOUTH = "2"
const WEST = "3"

// Controller states
const STATE_STARTING = 0
const STATE_MOVING = 1
const STATE_STOPPING = 2
const STATE_ROTATING = 3

// Window setup
const WIDTH = 1000
const HEIGHT = 700

DIRECTIONS = {
    NORTH: 1.5707963,  // PI/2
    EAST: 0.0,         // 0
    SOUTH: -1.5707963, // -PI/2
    WEST: 3.1415927    // PI
}

DIRECTION_NAMES= {
    NORTH: "NORTH",
    EAST: "EAST",           
    SOUTH: "SOUTH",
    WEST: "WEST"
}

// Cube class - represents a single colored cube
class Cube {
    init(x, y, z, size, color) {
        this.position = vec3(x, y, z)
        this.size = size
        this.color = color
        this.index = -1  // Will store batch index when added
        this.faceSize = nil  // Custom size for face cubes
    }
    
    add_to_batch(batch) {
        // Use custom face size if available, otherwise use default cube size
        var dimensions = this.faceSize
        if (dimensions == nil) {
            dimensions = vec3(this.size, this.size, this.size)
        }
        
        // Add the cube to the batch with its color and dimensions
        this.index = batch.add(this.position, dimensions, this.color)
        return this.index
    }
}

// CompositeCube class - a building block with colored window faces
class CompositeCube {    init(position, size) {
        this.position = position
        this.cubes = []
        this.size = size  // Use provided size instead of generating random
        
        // Create main black cube
        var blackColor = vec4(0, 0, 0, 255)
        var mainCube = Cube(position.x, position.y, position.z, this.size, blackColor)
        this.cubes.append(mainCube)
          // Create colored face overlays matching original design
        var halfSize = this.size / 2
        var faceOffset = 0.25  // Increased from 0.15 to reduce z-fighting
        var faceSize = this.size * 0.8  // 80% of cube size like original
        var faceThickness = 0.05  // Increased from 0.02 for better visibility
        
        // Front face (positive Z)
        var frontPos = vec3(position.x, position.y, position.z + halfSize + faceOffset)
        var frontColor = this.generateFaceColor()
        var frontCube = Cube(frontPos.x, frontPos.y, frontPos.z, faceThickness, frontColor)
        frontCube.faceSize = vec3(faceSize, faceSize, faceThickness)  // Store custom size
        this.cubes.append(frontCube)
        
        // Back face (negative Z)
        var backPos = vec3(position.x, position.y, position.z - halfSize - faceOffset)
        var backColor = this.generateFaceColor()
        var backCube = Cube(backPos.x, backPos.y, backPos.z, faceThickness, backColor)
        backCube.faceSize = vec3(faceSize, faceSize, faceThickness)
        this.cubes.append(backCube)
        
        // Right face (positive X)
        var rightPos = vec3(position.x + halfSize + faceOffset, position.y, position.z)
        var rightColor = this.generateFaceColor()
        var rightCube = Cube(rightPos.x, rightPos.y, rightPos.z, faceThickness, rightColor)
        rightCube.faceSize = vec3(faceThickness, faceSize, faceSize)
        this.cubes.append(rightCube)
        
        // Left face (negative X)
        var leftPos = vec3(position.x - halfSize - faceOffset, position.y, position.z)
        var leftColor = this.generateFaceColor()
        var leftCube = Cube(leftPos.x, leftPos.y, leftPos.z, faceThickness, leftColor)
        leftCube.faceSize = vec3(faceThickness, faceSize, faceSize)
        this.cubes.append(leftCube)
    }
      generateFaceColor() {
        // Create more muted, varied colors by reducing saturation and adjusting brightness
        var hue = random.integer(0, 360)
        var saturation = random.float(0.3, 0.7)  // Reduced from 0.6-0.9 for less primary colors
        var brightness = random.float(0.5, 0.85) // Reduced from 0.7-1.0 for more muted tones
        
        // Add some bias towards certain hue ranges for more pleasing color schemes
        var bias = random.integer(0, 3)
        if (bias == 0) {
            // Blues and teals
            hue = random.integer(180, 240)
        } else {
            if (bias == 1) {
                // Warm colors (reds, oranges, yellows)
                hue = random.integer(0, 60)
            } else {
                if (bias == 2) {
                    // Greens
                    hue = random.integer(90, 150)
                }
                // else use the random hue (bias == 3)
            }
        }
        
        return colour_utils.hsv_to_rgb(hue, saturation, brightness)
    }
    
    
    add_to_batch(batch) {
        // Add all cubes in this composite to the batch
        foreach (var cube in this.cubes) {
            cube.add_to_batch(batch)
        }
    }
}

// Stack class - a vertical stack of CompositeCubes
class Stack {
    init(gridX, gridZ, height) {
        this.gridX = gridX
        this.gridZ = gridZ
        this.height = height
        this.compositeCubes = []
          // Convert grid position to world coordinates
        var halfSize = int(CITY_SIZE / 2)
        var worldX = (gridX - halfSize) * STACK_SPACING
        var worldZ = (gridZ - halfSize) * STACK_SPACING
        
        var currentY = 0.0        // Create stack of composite cubes
        for (var i = 0; i < height; i = i + 1) {
            var cubeSize = BASE_CUBE_SIZE + random.float(-0.2, 0.4)  // Variation per level
            var position = vec3(worldX, currentY + cubeSize/2, worldZ)  // Center cube at currentY + half size
            
            var compositeCube = CompositeCube(position, cubeSize)  // Pass the size
            this.compositeCubes.append(compositeCube)
            
            currentY = currentY + cubeSize  // Use actual cube size to eliminate gaps
        }
    }
    
    add_to_batch(batch) {
        // Add all composite cubes to the batch
        foreach (var compositeCube in this.compositeCubes) {
            compositeCube.add_to_batch(batch)
        }
    }
}

// Grid class - manages the city layout with stacks and streets
class Grid {
    init(size) {
        this.size = size
        this.stacks = []
          // Create stacks only at odd grid positions (leaving even positions as streets)
        for (var x = 1; x < size; x = x + 2) {  // Odd positions only
            for (var z = 1; z < size; z = z + 2) {  // Odd positions only
                var stackHeight = random.integer(MIN_STACK_HEIGHT, MAX_STACK_HEIGHT + 1)
                var stack = Stack(x, z, stackHeight)
                this.stacks.append(stack)
            }
        }        var stackCount = len(this.stacks)
    }
    
    add_to_batch(batch) {
        // Add all stacks to the batch
        foreach (var stack in this.stacks) {
            stack.add_to_batch(batch)
        }
    }
      // Check if a grid position is valid for camera movement (even positions = streets)
    isValidStreetPosition(gridX, gridZ) {
        var validX = (gridX >= 0 and gridX < this.size)
        var validZ = (gridZ >= 0 and gridZ < this.size)
        var evenX = (gridX % 2 == 0)
        var evenZ = (gridZ % 2 == 0)
        return (validX and validZ and evenX and evenZ)
    }
      // Check if position is at grid boundary (will hit boundary in next move)
    isAtBoundary(gridX, gridZ, direction) {        if (direction == NORTH and gridZ >= this.size - 2) {  // Will hit boundary in next move
            return true
        }
        if (direction == SOUTH and gridZ <= 2) {  // Will hit boundary in next move
            return true
        }
        if (direction == EAST and gridX >= this.size - 2) {  // Will hit boundary in next move
            return true
        }
        if (direction == WEST and gridX <= 2) {  // Will hit boundary in next move
            return true
        }
        return false
    }
}

// Controller class - manages camera movement through the city
class Controller {
    init(grid) {
        this.grid = grid
        this.state = STATE_STARTING
        this.direction = NORTH
        this.speed = 0.0
        this.frameCount = 0

        // Rotation handling
        this.currentAngle = this.directionToAngle(this.direction)
        this.targetAngle = this.currentAngle
        this.newDirection = this.direction  // The new direction we're turning towards

        // Start at center of grid (even position = street)
        this.gridX = int(grid.size / 2)
        this.gridZ = int(grid.size / 2)
        if (this.gridX % 2 == 1) {
            this.gridX = this.gridX - 1  // Ensure even (street)
        }
        if (this.gridZ % 2 == 1) {
            this.gridZ = this.gridZ - 1  // Ensure even (street)       
        }

        // Convert to world coordinates
        var halfSize = int(grid.size / 2)
        this.worldX = (this.gridX - halfSize) * STACK_SPACING
        this.worldZ = (this.gridZ - halfSize) * STACK_SPACING
        
        // Target position for stopping at intersections
        this.targetWorldX = this.worldX
        this.targetWorldZ = this.worldZ
        this.hasTarget = false  // Whether we have a specific stopping target
        
        // Track last intersection to avoid immediate re-triggering
        this.lastIntersectionX = this.gridX
        this.lastIntersectionZ = this.gridZ
    }

    update() {
        this.frameCount = this.frameCount + 1
        
        if (this.state == STATE_STARTING) {
            this.updateStarting()
        }
        if (this.state == STATE_MOVING) {
            this.updateMoving()
        }
        if (this.state == STATE_STOPPING) {
            this.updateStopping()
        }
        if (this.state == STATE_ROTATING) {
            this.updateRotating()        
        }
        
        // Move the camera
        this.moveCamera()
    }

    updateStarting() {
        // Ramp up speed over ACCELERATION_FRAMES
        var progress = this.frameCount / float(ACCELERATION_FRAMES)
        if (progress >= 1.0) {
            this.speed = MAX_CAMERA_SPEED
            this.state = STATE_MOVING
            this.frameCount = 0
        } else {
            this.speed = MAX_CAMERA_SPEED * progress * progress  // Smooth acceleration
        }
        this.passed = 0 
    }    
    updateMoving() {
        // Check if we're at a NEW intersection
        var atIntersection = (this.gridX % 2 == 0 and this.gridZ % 2 == 0)
        var newIntersection = atIntersection and (this.gridX != this.lastIntersectionX or this.gridZ != this.lastIntersectionZ)
        
        if (newIntersection) {
             
            this.passed += 1
            this.lastIntersectionX = this.gridX
            this.lastIntersectionZ = this.gridZ
            
            // Check if we should turn  
            var shouldTurn = (random.integer(1, 10) == 1) or this.passed >= 10 
            var atBoundary = this.isAtBoundary()
          
            
            if (shouldTurn or atBoundary) {
               
                // Set target to next intersection in current direction
                this.setStoppingTarget()
                this.chooseNewDirection()
                this.state = STATE_STOPPING
                this.frameCount = 0
                this.hasTarget = true
                this.passed = 0 
            }
        }
    }
    
    setStoppingTarget() {
        // Find the next intersection in our current direction
        var nextGridX = this.gridX
        var nextGridZ = this.gridZ
        
        if (this.direction == NORTH) {
            nextGridZ = nextGridZ + 2
        }
        if (this.direction == SOUTH) {
            nextGridZ = nextGridZ - 2
        }
        if (this.direction == EAST) {
            nextGridX = nextGridX + 2
        }
        if (this.direction == WEST) {
            nextGridX = nextGridX - 2
        }
        
        // Convert to world coordinates
        var halfSize = int(this.grid.size / 2)
        this.targetWorldX = (nextGridX - halfSize) * STACK_SPACING
        this.targetWorldZ = (nextGridZ - halfSize) * STACK_SPACING
    }    
    updateStopping() {
        if (this.hasTarget) {
            // Calculate distance to target
            var distanceToTarget = math.sqrt((this.targetWorldX - this.worldX) * (this.targetWorldX - this.worldX) + 
                                           (this.targetWorldZ - this.worldZ) * (this.targetWorldZ - this.worldZ))
            
            // Calculate required deceleration to stop at target
            // Using physics: v² = 2as, solve for a: a = v²/(2s)
            var requiredDecel = (this.speed * this.speed) / (2.0 * math.max(distanceToTarget, 0.1))
            var maxDecel = MAX_CAMERA_SPEED / float(DECELERATION_FRAMES)  // Maximum allowed deceleration
            
            // Use the higher of required or maximum deceleration to ensure we stop in time
            var deceleration = math.max(requiredDecel, maxDecel)
            
            // Apply deceleration
            this.speed = math.max(0.0, this.speed - deceleration)
            
            // Check if we've reached the target or stopped
            if (distanceToTarget < 0.5 or this.speed <= 0.01) {
                this.speed = 0.0
                this.state = STATE_ROTATING
                this.frameCount = 0
                this.hasTarget = false
                
                // Snap to target position
                this.worldX = this.targetWorldX
                this.worldZ = this.targetWorldZ
                
                // Update grid position
                var halfSize = int(this.grid.size / 2)
                this.gridX = int((this.worldX / STACK_SPACING) + halfSize + 0.5)
                this.gridZ = int((this.worldZ / STACK_SPACING) + halfSize + 0.5)
                
                // Ensure even coordinates (street centers)
                if (this.gridX % 2 == 1) {
                    this.gridX = this.gridX - 1
                }
                if (this.gridZ % 2 == 1) {
                    this.gridZ = this.gridZ - 1
                }
            }
        } else {
            // Fallback: time-based deceleration if no target
            var progress = this.frameCount / float(DECELERATION_FRAMES)
            if (progress >= 1.0) {
                this.speed = 0.0
                this.state = STATE_ROTATING
                this.frameCount = 0
            } else {
                var remaining = 1.0 - progress
                this.speed = MAX_CAMERA_SPEED * remaining * remaining
            }
        }
    }

    updateRotating() {
        // Rotate smoothly over ROTATION_FRAMES
        var progress = this.frameCount / float(ROTATION_FRAMES)
        if (progress >= 1.0) {
            this.currentAngle = this.targetAngle
            this.direction = this.newDirection
            this.state = STATE_STARTING
            this.frameCount = 0
        } else {
            // Smooth interpolation
            var t = progress * progress * (3.0 - 2.0 * progress)  // Smoothstep
            
            // Handle angle wrapping
            var angleDiff = this.targetAngle - this.currentAngle
             
            if (angleDiff > math.PI) {
                angleDiff = angleDiff - 2.0 * math.PI
            }
            if (angleDiff < -math.PI) {
                angleDiff = angleDiff + 2.0 * math.PI
            }
            
            this.currentAngle = this.currentAngle + angleDiff * t
        }
    }

    moveCamera() {
        if (this.speed > 0) {
            // Move forward in current direction
            var moveX = math.sin(this.currentAngle) * this.speed
            var moveZ = math.cos(this.currentAngle) * this.speed
            
            this.worldX = this.worldX + moveX
            this.worldZ = this.worldZ + moveZ
            
            // Update grid position
            var halfSize = int(this.grid.size / 2)
            this.gridX = int((this.worldX / STACK_SPACING) + halfSize + 0.5)
            this.gridZ = int((this.worldZ / STACK_SPACING) + halfSize + 0.5)
            
            // Snap to street centers (even coordinates)
            if (this.gridX % 2 == 1) {
                this.gridX = this.gridX - 1
            }
            if (this.gridZ % 2 == 1) {
                this.gridZ = this.gridZ - 1
            }
        }
    }

    isAtBoundary() {
         

        if (  this.gridZ >= this.grid.size -1 ) {
            return true
        }
        if (  this.gridZ <= 1) {
            return true
        }
        if ( this.gridX >= this.grid.size -1  ) {
            return true
        }
        if (  this.gridX <= 1 ) {
            return true
        }
        return false
    }

    chooseNewDirection() {
        // Pick left or right from current direction
        var directions = [NORTH, EAST, SOUTH, WEST]
        var currentIndex = 0
        
        // Find current direction index
        for (var i = 0; i < 4; i = i + 1) {
            if (directions[i] == this.direction) {
                currentIndex = i
                break
            }
        }
        
        // Choose left or right (50/50 chance)
        var turnLeft = random.integer(0, 2) == 0
        var newIndex = currentIndex
        
        if (turnLeft) {
            newIndex = (currentIndex + 3) % 4  // Turn left (counterclockwise)
        } else {
            newIndex = (currentIndex + 1) % 4  // Turn right (clockwise)
        }
        
        this.newDirection = directions[newIndex]
        this.targetAngle = this.directionToAngle(this.newDirection)
    }

    directionToAngle(direction) {
        return DIRECTIONS[direction]
    }

    getCamera() {
        // Simple camera pointing in current direction
        var camY = CAMERA_HEIGHT + math.sin(this.worldX * 0.05) * 1.0
        
        var lookDistance = 25.0
        var lookX = this.worldX + math.sin(this.currentAngle) * lookDistance
        var lookZ = this.worldZ + math.cos(this.currentAngle) * lookDistance
          
        var camPos = vec3(this.worldX, camY, this.worldZ)
        var lookPos = vec3(lookX, CAMERA_HEIGHT, lookZ)
        var upVec = vec3(0, 1, 0)
        return camera(camPos, lookPos, upVec)
    }
}
// Initialize application
var win = window(WIDTH, HEIGHT)
win.init()
win.set_target_fps(60)
if (FULLSCREEN) {
    win.toggle_fullscreen()
}  
 
// Create batch for all cubes
var cubeBatch = batch(win.BATCH_CUBE)

// Create grid and populate with stacks
var grid = Grid(CITY_SIZE)
grid.add_to_batch(cubeBatch)

// Create controller
var controller = Controller(grid)

// Main render loop
var frameCounter = 0
while (!win.should_close()) {
    frameCounter = frameCounter + 1
    
    win.begin()
    win.begin_blend_mode(win.BLEND_ALPHA)
    win.clear(vec4(40, 10, 10, 255))  // Dark red background like original
    
    // Update controller
    controller.update()
    
    // Get camera from controller
    var cam = controller.getCamera()
    
    // Begin 3D rendering
    win.begin_3d(cam)
    
    // Draw ground plane
    var groundSize = CITY_SIZE * STACK_SPACING * 1.2
    win.plane(vec3(0, -1, 0), vec2(groundSize, groundSize), vec4(15, 15, 15, 255))
    
    // Draw all cubes in one batched call
    cubeBatch.draw()
   
    
    win.end_3d()
    win.end()
}

win.close()
